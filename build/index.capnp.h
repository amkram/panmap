// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: index.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1001000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(b5aa944985125175);
CAPNP_DECLARE_SCHEMA(b79f12ff3ad8ac72);
CAPNP_DECLARE_SCHEMA(995c518649fb4e52);
CAPNP_DECLARE_SCHEMA(bcc9211f332fec0c);
CAPNP_DECLARE_SCHEMA(85c72cd00296e080);

}  // namespace schemas
}  // namespace capnp


struct MapDelta {
  MapDelta() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct MaybeValue;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b5aa944985125175, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MapDelta::MaybeValue {
  MaybeValue() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    VALUE,
    NONE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b79f12ff3ad8ac72, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GapMutations {
  GapMutations() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(995c518649fb4e52, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct SeedMutations {
  SeedMutations() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bcc9211f332fec0c, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Index {
  Index() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(85c72cd00296e080, 3, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class MapDelta::Reader {
public:
  typedef MapDelta Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getPos() const;

  inline typename MaybeValue::Reader getMaybeValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapDelta::Builder {
public:
  typedef MapDelta Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getPos();
  inline void setPos( ::int32_t value);

  inline typename MaybeValue::Builder getMaybeValue();
  inline typename MaybeValue::Builder initMaybeValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapDelta::Pipeline {
public:
  typedef MapDelta Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename MaybeValue::Pipeline getMaybeValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapDelta::MaybeValue::Reader {
public:
  typedef MaybeValue Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isValue() const;
  inline  ::int64_t getValue() const;

  inline bool isNone() const;
  inline  ::capnp::Void getNone() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapDelta::MaybeValue::Builder {
public:
  typedef MaybeValue Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isValue();
  inline  ::int64_t getValue();
  inline void setValue( ::int64_t value);

  inline bool isNone();
  inline  ::capnp::Void getNone();
  inline void setNone( ::capnp::Void value = ::capnp::VOID);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapDelta::MaybeValue::Pipeline {
public:
  typedef MaybeValue Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GapMutations::Reader {
public:
  typedef GapMutations Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasDeltas() const;
  inline  ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>::Reader getDeltas() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GapMutations::Builder {
public:
  typedef GapMutations Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasDeltas();
  inline  ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>::Builder getDeltas();
  inline void setDeltas( ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>::Builder initDeltas(unsigned int size);
  inline void adoptDeltas(::capnp::Orphan< ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>> disownDeltas();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GapMutations::Pipeline {
public:
  typedef GapMutations Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class SeedMutations::Reader {
public:
  typedef SeedMutations Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasBasePositions() const;
  inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader getBasePositions() const;

  inline bool hasPerPosMasks() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getPerPosMasks() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class SeedMutations::Builder {
public:
  typedef SeedMutations Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasBasePositions();
  inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder getBasePositions();
  inline void setBasePositions( ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setBasePositions(::kj::ArrayPtr<const  ::int64_t> value);
  inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder initBasePositions(unsigned int size);
  inline void adoptBasePositions(::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>> disownBasePositions();

  inline bool hasPerPosMasks();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getPerPosMasks();
  inline void setPerPosMasks( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setPerPosMasks(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initPerPosMasks(unsigned int size);
  inline void adoptPerPosMasks(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownPerPosMasks();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class SeedMutations::Pipeline {
public:
  typedef SeedMutations Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Index::Reader {
public:
  typedef Index Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getK() const;

  inline  ::int32_t getS() const;

  inline  ::int32_t getT() const;

  inline  ::int32_t getL() const;

  inline bool getOpen() const;

  inline bool hasPerNodeSeedMutations() const;
  inline  ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>::Reader getPerNodeSeedMutations() const;

  inline bool hasPerNodeGapMutations() const;
  inline  ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>::Reader getPerNodeGapMutations() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Index::Builder {
public:
  typedef Index Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getK();
  inline void setK( ::int32_t value);

  inline  ::int32_t getS();
  inline void setS( ::int32_t value);

  inline  ::int32_t getT();
  inline void setT( ::int32_t value);

  inline  ::int32_t getL();
  inline void setL( ::int32_t value);

  inline bool getOpen();
  inline void setOpen(bool value);

  inline bool hasPerNodeSeedMutations();
  inline  ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>::Builder getPerNodeSeedMutations();
  inline void setPerNodeSeedMutations( ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>::Builder initPerNodeSeedMutations(unsigned int size);
  inline void adoptPerNodeSeedMutations(::capnp::Orphan< ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>> disownPerNodeSeedMutations();

  inline bool hasPerNodeGapMutations();
  inline  ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>::Builder getPerNodeGapMutations();
  inline void setPerNodeGapMutations( ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>::Builder initPerNodeGapMutations(unsigned int size);
  inline void adoptPerNodeGapMutations(::capnp::Orphan< ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>> disownPerNodeGapMutations();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Index::Pipeline {
public:
  typedef Index Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::int32_t MapDelta::Reader::getPos() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t MapDelta::Builder::getPos() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MapDelta::Builder::setPos( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline typename MapDelta::MaybeValue::Reader MapDelta::Reader::getMaybeValue() const {
  return typename MapDelta::MaybeValue::Reader(_reader);
}
inline typename MapDelta::MaybeValue::Builder MapDelta::Builder::getMaybeValue() {
  return typename MapDelta::MaybeValue::Builder(_builder);
}
#if !CAPNP_LITE
inline typename MapDelta::MaybeValue::Pipeline MapDelta::Pipeline::getMaybeValue() {
  return typename MapDelta::MaybeValue::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename MapDelta::MaybeValue::Builder MapDelta::Builder::initMaybeValue() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  return typename MapDelta::MaybeValue::Builder(_builder);
}
inline  ::MapDelta::MaybeValue::Which MapDelta::MaybeValue::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline  ::MapDelta::MaybeValue::Which MapDelta::MaybeValue::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline bool MapDelta::MaybeValue::Reader::isValue() const {
  return which() == MapDelta::MaybeValue::VALUE;
}
inline bool MapDelta::MaybeValue::Builder::isValue() {
  return which() == MapDelta::MaybeValue::VALUE;
}
inline  ::int64_t MapDelta::MaybeValue::Reader::getValue() const {
  KJ_IREQUIRE((which() == MapDelta::MaybeValue::VALUE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int64_t MapDelta::MaybeValue::Builder::getValue() {
  KJ_IREQUIRE((which() == MapDelta::MaybeValue::VALUE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void MapDelta::MaybeValue::Builder::setValue( ::int64_t value) {
  _builder.setDataField<MapDelta::MaybeValue::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, MapDelta::MaybeValue::VALUE);
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool MapDelta::MaybeValue::Reader::isNone() const {
  return which() == MapDelta::MaybeValue::NONE;
}
inline bool MapDelta::MaybeValue::Builder::isNone() {
  return which() == MapDelta::MaybeValue::NONE;
}
inline  ::capnp::Void MapDelta::MaybeValue::Reader::getNone() const {
  KJ_IREQUIRE((which() == MapDelta::MaybeValue::NONE),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void MapDelta::MaybeValue::Builder::getNone() {
  KJ_IREQUIRE((which() == MapDelta::MaybeValue::NONE),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MapDelta::MaybeValue::Builder::setNone( ::capnp::Void value) {
  _builder.setDataField<MapDelta::MaybeValue::Which>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, MapDelta::MaybeValue::NONE);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool GapMutations::Reader::hasDeltas() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GapMutations::Builder::hasDeltas() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>::Reader GapMutations::Reader::getDeltas() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>::Builder GapMutations::Builder::getDeltas() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GapMutations::Builder::setDeltas( ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>::Builder GapMutations::Builder::initDeltas(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void GapMutations::Builder::adoptDeltas(
    ::capnp::Orphan< ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>> GapMutations::Builder::disownDeltas() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::MapDelta,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SeedMutations::Reader::hasBasePositions() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool SeedMutations::Builder::hasBasePositions() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader SeedMutations::Reader::getBasePositions() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder SeedMutations::Builder::getBasePositions() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void SeedMutations::Builder::setBasePositions( ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void SeedMutations::Builder::setBasePositions(::kj::ArrayPtr<const  ::int64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>::Builder SeedMutations::Builder::initBasePositions(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void SeedMutations::Builder::adoptBasePositions(
    ::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>> SeedMutations::Builder::disownBasePositions() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::int64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool SeedMutations::Reader::hasPerPosMasks() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool SeedMutations::Builder::hasPerPosMasks() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader SeedMutations::Reader::getPerPosMasks() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder SeedMutations::Builder::getPerPosMasks() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void SeedMutations::Builder::setPerPosMasks( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void SeedMutations::Builder::setPerPosMasks(::kj::ArrayPtr<const  ::uint64_t> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder SeedMutations::Builder::initPerPosMasks(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void SeedMutations::Builder::adoptPerPosMasks(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> SeedMutations::Builder::disownPerPosMasks() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::int32_t Index::Reader::getK() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Index::Builder::getK() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Index::Builder::setK( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Index::Reader::getS() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Index::Builder::getS() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Index::Builder::setS( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Index::Reader::getT() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Index::Builder::getT() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Index::Builder::setT( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Index::Reader::getL() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Index::Builder::getL() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Index::Builder::setL( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool Index::Reader::getOpen() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS);
}

inline bool Index::Builder::getOpen() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS);
}
inline void Index::Builder::setOpen(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<128>() * ::capnp::ELEMENTS, value);
}

inline bool Index::Reader::hasPerNodeSeedMutations() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Index::Builder::hasPerNodeSeedMutations() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>::Reader Index::Reader::getPerNodeSeedMutations() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>::Builder Index::Builder::getPerNodeSeedMutations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Index::Builder::setPerNodeSeedMutations( ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>::Builder Index::Builder::initPerNodeSeedMutations(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Index::Builder::adoptPerNodeSeedMutations(
    ::capnp::Orphan< ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>> Index::Builder::disownPerNodeSeedMutations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::SeedMutations,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Index::Reader::hasPerNodeGapMutations() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Index::Builder::hasPerNodeGapMutations() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>::Reader Index::Reader::getPerNodeGapMutations() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>::Builder Index::Builder::getPerNodeGapMutations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Index::Builder::setPerNodeGapMutations( ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>::Builder Index::Builder::initPerNodeGapMutations(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Index::Builder::adoptPerNodeGapMutations(
    ::capnp::Orphan< ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>> Index::Builder::disownPerNodeGapMutations() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::GapMutations,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}


CAPNP_END_HEADER

